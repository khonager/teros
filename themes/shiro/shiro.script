// --- SHIRO CONFIGURATION ---
NUM = 22;           // 21 Frames (0 to 20)
SPEED = 4;          // Doubled for half speed          

screen.w = Window.GetWidth(0);
screen.h = Window.GetHeight(0);
screen.half.w = screen.w / 2;
screen.half.h = screen.h / 2;

for (i = 0; i < NUM; i++)
  flyingman_image[i] = Image("progress-" + i + ".png");

flyingman_sprite = Sprite();

if (flyingman_image[0]) {
    flyingman_sprite.SetX(screen.half.w - flyingman_image[0].GetWidth() / 2);
    flyingman_sprite.SetY(screen.half.h - flyingman_image[0].GetHeight() / 2);
}

progress = 0;

fun refresh_callback ()
  {
    frame_index = Math.Int(progress / SPEED) % NUM;
    flyingman_sprite.SetImage(flyingman_image[frame_index]);
    progress++;
  }

Plymouth.SetRefreshFunction (refresh_callback);

// --- PASSWORD HANDLING (Chess Unicode Symbols) ---
bullets_sprites = [];
bullets_images = [];

password_area_y = screen.half.h + 100;

// Binary symbols for matrix-style password display
symbols[0] = "0";
symbols[1] = "1";

fun DisplayPasswordCallback(prompt, bullets) {
    actual_bullets = bullets;
    
    // Calculate visual bullets with shoulder-surfing protection
    // Each character: 20% show 0, 60% show 1, 20% show 2
    visual_bullets = 0;
    for (j = 0; j < actual_bullets; j++) {
        chance = (j * 17 + j * j * 7 + j * 31) % 5;
        if (chance == 0)
            visual_bullets = visual_bullets + 0;  // 20% - skip
        else if (chance == 4)
            visual_bullets = visual_bullets + 2;  // 20% - double
        else
            visual_bullets = visual_bullets + 1;  // 60% - normal
    }
    
    // 1. Cleanup excess sprites
    i = visual_bullets;
    while (bullets_sprites[i]) {
        bullets_sprites[i].SetImage(NULL);
        bullets_sprites[i] = NULL;
        bullets_images[i] = NULL;
        i++;
    }
    
    // 2. Add/Update visual bullets
    start_x = screen.half.w - (visual_bullets * 15);

    for (i = 0; i < visual_bullets; i++) {
        if (!bullets_sprites[i]) {
            // Pseudo-random 0 or 1 based on index, total, and timing
            sym_index = (i + visual_bullets * 7 + i * 13 + progress) % 2;
            sym = symbols[sym_index];
            
            // Random color: #9c36a3 (purple) or #fefbff (off-white)
            color_index = (i + visual_bullets * 3 + i * 11 + progress) % 2;
            if (color_index == 0)
                img = Image.Text(sym, 0.612, 0.212, 0.639);  // #9c36a3
            else
                img = Image.Text(sym, 0.996, 0.984, 1.0);    // #fefbff 
            spr = Sprite(img);
            
            bullets_images[i] = img;
            bullets_sprites[i] = spr;
        }
        
        bullets_sprites[i].SetX(start_x + (i * 30));
        bullets_sprites[i].SetY(password_area_y);
        bullets_sprites[i].SetZ(100);
    }
}

// Message sprite for errors
message_sprite = Sprite();
message_sprite.SetPosition(screen.half.w, password_area_y + 50, 100);

fun DisplayMessageCallback(text) {
    my_image = Image.Text(text, 0.8, 0.0, 0.0);
    message_sprite.SetImage(my_image);
    message_sprite.SetX(screen.half.w - my_image.GetWidth() / 2);
    message_sprite.SetY(password_area_y + 50);
}

Plymouth.SetDisplayPasswordFunction(DisplayPasswordCallback);
Plymouth.SetMessageFunction(DisplayMessageCallback);

fun DisplayNormalCallback() { state.status = "play"; }
fun QuitCallback() { state.status = "quit"; }
Plymouth.SetDisplayNormalFunction(DisplayNormalCallback);
Plymouth.SetQuitFunction(QuitCallback);