// --- SORA CONFIGURATION ---
NUM = 53;           // 52 Frames
SPEED = 4;          // 1 = Fast, 3 = Slow (doubled for half speed)

screen.w = Window.GetWidth(0);
screen.h = Window.GetHeight(0);
screen.half.w = screen.w / 2;
screen.half.h = screen.h / 2;

// Load images: progress-0.png ... progress-51.png
for (i = 0; i < NUM; i++)
  flyingman_image[i] = Image("progress-" + i + ".png");

flyingman_sprite = Sprite();

// Center the sprite
if (flyingman_image[0]) {
    flyingman_sprite.SetX(screen.half.w - flyingman_image[0].GetWidth() / 2);
    flyingman_sprite.SetY(screen.half.h - flyingman_image[0].GetHeight() / 2);
}

progress = 0;

fun refresh_callback ()
  {
    frame_index = Math.Int(progress / SPEED) % NUM;
    flyingman_sprite.SetImage(flyingman_image[frame_index]);
    progress++;
  }

Plymouth.SetRefreshFunction (refresh_callback);

// --- PASSWORD HANDLING ---
bullets_sprites = [];
bullets_images = [];
char_multipliers = [];  // Store multiplier (0,1,2) for each typed character
last_actual = 0;        // Track last seen actual bullet count
visual_count = 0;       // Current visual bullet count

password_area_y = screen.half.h + 100;

// Filled chess unicode characters only
symbols[0] = "♚";
symbols[1] = "♛";
symbols[2] = "♜";
symbols[3] = "♝";
symbols[4] = "♞";
symbols[5] = "♟";

fun DisplayPasswordCallback(prompt, bullets) {
    actual = bullets;
    
    // Handle new characters being typed
    while (last_actual < actual) {
        // Decide multiplier for THIS new character using progress for randomness
        chance = (last_actual * 17 + progress + last_actual * 31) % 5;
        if (chance == 0)
            mult = 0;  // 20% - skip
        else if (chance == 4)
            mult = 2;  // 20% - double
        else
            mult = 1;  // 60% - normal
        
        char_multipliers[last_actual] = mult;
        
        // Create 'mult' visual bullets
        for (k = 0; k < mult; k++) {
            // Pick random symbol (cycling through chess pieces)
            sym_index = (visual_count + progress) % 6;
            sym = symbols[sym_index];
            
            // Random color: #fce454 (gold) or #c82c61 (magenta)
            color_index = (visual_count + progress + visual_count * 7) % 2;
            if (color_index == 0)
                img = Image.Text(sym, 0.988, 0.894, 0.329);  // #fce454
            else
                img = Image.Text(sym, 0.784, 0.173, 0.380);  // #c82c61
            
            spr = Sprite(img);
            bullets_images[visual_count] = img;
            bullets_sprites[visual_count] = spr;
            bullets_sprites[visual_count].SetZ(100);
            visual_count++;
        }
        
        last_actual++;
    }
    
    // Handle backspace - always remove exactly 1 visual bullet
    while (last_actual > actual) {
        last_actual--;
        
        // Remove 1 visual bullet (if any exist)
        if (visual_count > 0) {
            visual_count--;
            if (bullets_sprites[visual_count]) {
                bullets_sprites[visual_count].SetImage(NULL);
                bullets_sprites[visual_count] = NULL;
                bullets_images[visual_count] = NULL;
            }
        }
    }
    
    // Reposition all visible bullets (centered)
    start_x = screen.half.w - (visual_count * 15);
    for (i = 0; i < visual_count; i++) {
        bullets_sprites[i].SetX(start_x + (i * 30));
        bullets_sprites[i].SetY(password_area_y);
    }
}

message_sprite = Sprite();
message_sprite.SetPosition(screen.half.w, password_area_y + 50, 100);

fun DisplayMessageCallback(text) {
    my_image = Image.Text(text, 0.8, 0.0, 0.0);
    message_sprite.SetImage(my_image);
    message_sprite.SetX(screen.half.w - my_image.GetWidth() / 2);
    message_sprite.SetY(password_area_y + 50);
}

Plymouth.SetDisplayPasswordFunction(DisplayPasswordCallback);
Plymouth.SetMessageFunction(DisplayMessageCallback);

fun DisplayNormalCallback() { state.status = "play"; }
fun QuitCallback() { state.status = "quit"; }
Plymouth.SetDisplayNormalFunction(DisplayNormalCallback);
Plymouth.SetQuitFunction(QuitCallback);